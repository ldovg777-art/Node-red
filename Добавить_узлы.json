[
    {
        "id": "1da848c11508168c",
        "type": "range",
        "z": "35f5405f4562777c",
        "minin": "-5000",
        "maxin": "5000",
        "minout": "0",
        "maxout": "4095",
        "action": "scale",
        "round": true,
        "property": "payload",
        "name": "",
        "x": 3340,
        "y": 280,
        "wires": [
            [
                "efb289b7be6629d3",
                "9d63e2a78197bee0",
                "d639f09e809bc875"
            ]
        ]
    },
    {
        "id": "efb289b7be6629d3",
        "type": "ADAM-write",
        "z": "35f5405f4562777c",
        "name": "6224",
        "host": "192.168.2.2",
        "serialPortCfg": "",
        "unit_id": 1,
        "write_ch": 0,
        "write_ch_type": "write_ao_1",
        "reconnecttimeout": "",
        "Series": "mbtcp",
        "advDevTypeTCP": "ADAM-6224",
        "advDevTypeRTU": "ADAM-4022T",
        "advDevType": "ADAM-6224",
        "x": 3570,
        "y": 360,
        "wires": []
    },
    {
        "id": "e6f55194793704a3",
        "type": "get-ai-value",
        "z": "35f5405f4562777c",
        "name": "6717",
        "x": 3570,
        "y": 200,
        "wires": [
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            []
        ]
    },
    {
        "id": "d639f09e809bc875",
        "type": "delay",
        "z": "35f5405f4562777c",
        "name": "",
        "pauseType": "delay",
        "timeout": "0",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 3420,
        "y": 140,
        "wires": [
            [
                "e6f55194793704a3"
            ]
        ]
    },
    {
        "id": "52e41fa267c961c4",
        "type": "function",
        "z": "35f5405f4562777c",
        "name": "Отображение значения",
        "func": "const reason = msg.reason || '';\nconst command = msg.command || '';\nconst outputs = [null, null, null, null, null, null];\nconst MAX_BUFFER_SIZE = 20000;\nconst EXPORT_KEY = 'trendExportData';\nconst EXPORT_READY_KEY = 'trendExportReady';\n\nfunction ensureBuffer() {\n    const current = flow.get('trendBuffer');\n    if (current && typeof current === 'object') {\n        const labels = Array.isArray(current.labels) ? current.labels : [];\n        const value = Array.isArray(current.value) ? current.value : [];\n        const step = Array.isArray(current.step) ? current.step : [];\n        return { labels, value, step };\n    }\n    return { labels: [], value: [], step: [] };\n}\n\nfunction formatTimestamp(ts) {\n    const numeric = Number(ts);\n    if (Number.isFinite(numeric)) {\n        try {\n            return new Date(numeric).toISOString();\n        } catch (err) {\n            // ignore\n        }\n    }\n    return new Date().toISOString();\n}\n\nfunction getCycleStartTime() {\n    const stored = flow.get('cycleStartTime');\n    return Number.isFinite(Number(stored)) ? Number(stored) : null;\n}\n\nfunction setCycleStartTime(ts) {\n    if (Number.isFinite(Number(ts))) {\n        flow.set('cycleStartTime', Number(ts));\n    }\n}\n\nfunction appendPoint(buffer, value, step, ts) {\n    if (!Number.isFinite(value) || !Number.isFinite(step)) {\n        return;\n    }\n\n    while (buffer.labels.length >= MAX_BUFFER_SIZE) {\n        buffer.labels.shift();\n        buffer.value.shift();\n        buffer.step.shift();\n    }\n\n    // Временная шкала всегда начинается с нуля\n    // Если буфер пуст, это первая точка - время = 0\n    // Если буфер не пуст, вычисляем время относительно первой точки\n    let relativeTime = 0;\n    if (buffer.labels.length === 0) {\n        // Первая точка всегда имеет время 0\n        relativeTime = 0;\n        // Сохраняем timestamp первой точки для последующих вычислений\n        if (Number.isFinite(Number(ts))) {\n            setCycleStartTime(Number(ts));\n        }\n    } else {\n        // Вычисляем время относительно первой точки\n        const cycleStart = getCycleStartTime();\n        if (cycleStart !== null && Number.isFinite(Number(ts))) {\n            relativeTime = Math.max(0, Number(ts) - cycleStart);\n        } else {\n            // Если cycleStart не установлен, используем последнее время + минимальный шаг\n            const lastTime = buffer.labels.length > 0 ? Number(buffer.labels[buffer.labels.length - 1]) : 0;\n            relativeTime = lastTime + 1; // Минимальный шаг 1 мс\n        }\n    }\n    \n    // Используем относительное время как timestamp (в миллисекундах от 0)\n    buffer.labels.push(relativeTime);\n    buffer.value.push(value);\n    buffer.step.push(step);\n}\n\nfunction cloneBuffer(buffer) {\n    return {\n        labels: buffer.labels.slice(),\n        value: buffer.value.slice(),\n        step: buffer.step.slice()\n    };\n}\n\nfunction toTimestamp(value) {\n    if (value instanceof Date) {\n        return value.getTime();\n    }\n    const parsed = Date.parse(value);\n    if (Number.isFinite(parsed)) {\n        return parsed;\n    }\n    const numeric = Number(value);\n    if (Number.isFinite(numeric)) {\n        return numeric;\n    }\n    return NaN;\n}\n\nfunction createSeriesPoints(labels, seriesValues) {\n    const points = [];\n    const length = Math.min(labels.length, seriesValues.length);\n    for (let i = 0; i < length; i += 1) {\n        // labels уже содержат относительное время в миллисекундах\n        const x = Number(labels[i]);\n        const y = Number(seriesValues[i]);\n        if (Number.isFinite(x) && Number.isFinite(y)) {\n            points.push({ x, y });\n        }\n    }\n    return points;\n}\n\nfunction buildChartMessages(buffer, options = {}) {\n    const { forceClear = false } = options;\n    const messages = [];\n\n    if (forceClear) {\n        messages.push({ ui_control: { clear: true } });\n    }\n\n    const valueSeries = createSeriesPoints(buffer.labels, buffer.value);\n    const stepSeries = createSeriesPoints(buffer.labels, buffer.step);\n\n    if (valueSeries.length || stepSeries.length) {\n        messages.push({\n            payload: [\n                {\n                    series: ['ITERATION_VALUE', 'ITERATION_STEP'],\n                    data: [valueSeries, stepSeries],\n                    labels: []\n                }\n            ],\n            topic: 'ITERATION_BUFFER'\n        });\n    }\n\n    return messages;\n}\n\n\nfunction resetBuffer(buffer) {\n    buffer.labels = [];\n    buffer.value = [];\n    buffer.step = [];\n}\n\nfunction storeExportSnapshot(snapshot) {\n    flow.set(EXPORT_KEY, snapshot);\n    flow.set(EXPORT_READY_KEY, snapshot.labels.length > 0);\n}\n\nfunction getExportSnapshot() {\n    const data = flow.get(EXPORT_KEY);\n    if (data && typeof data === 'object') {\n        const labels = Array.isArray(data.labels) ? data.labels : [];\n        const value = Array.isArray(data.value) ? data.value : [];\n        const step = Array.isArray(data.step) ? data.step : [];\n        return { labels, value, step };\n    }\n    return { labels: [], value: [], step: [] };\n}\n\nfunction clearExportSnapshot() {\n    flow.set(EXPORT_KEY, { labels: [], value: [], step: [] });\n    flow.set(EXPORT_READY_KEY, false);\n}\n\nconst buffer = ensureBuffer();\nconst numericValue = Number(msg.payload);\nconst stepCandidate = Number(msg.step);\nconst stepValue = Number.isFinite(stepCandidate) ? stepCandidate : Number(global.get('ITERATION_STEP'));\nconst timestamp = Number.isFinite(Number(msg.ts)) ? Number(msg.ts) : Date.now();\n\nif (reason === 'tick') {\n    appendPoint(buffer, numericValue, stepValue, timestamp);\n}\n\nif (reason === 'restart' || reason === 'stop') {\n    resetBuffer(buffer);\n    clearExportSnapshot();\n    if (reason === 'restart') {\n        setCycleStartTime(timestamp);\n    } else if (reason === 'stop') {\n        flow.set('cycleStartTime', null);\n    }\n    outputs[0] = [{ ui_control: { clear: true } }];\n    node.status({ fill: 'grey', shape: 'dot', text: 'Буфер очищен' });\n}\n\nconst startTriggers = ['restart', 'nextStep', 'pauseComplete', 'pauseHold', 'cycleResume'];\nif (startTriggers.includes(reason)) {\n    if (reason === 'restart' || (reason === 'nextStep' && stepValue === 1)) {\n        setCycleStartTime(timestamp);\n    }\n    appendPoint(buffer, numericValue, stepValue, timestamp);\n}\n\nif (reason && Number.isFinite(numericValue)) {\n    outputs[2] = { payload: numericValue };\n}\n\nif (reason && Number.isFinite(stepValue)) {\n    outputs[3] = { payload: stepValue };\n}\n\nif (command === 'manualFlush') {\n    const snapshot = cloneBuffer(buffer);\n    if (snapshot.labels.length) {\n        outputs[0] = buildChartMessages(snapshot, { forceClear: true });\n        node.status({ fill: 'blue', shape: 'ring', text: `Ручная отрисовка (${snapshot.labels.length})` });\n    } else {\n        node.status({ fill: 'yellow', shape: 'ring', text: 'Буфер пуст' });\n    }\n}\n\nif (reason === 'cycleComplete') {\n    const snapshot = cloneBuffer(buffer);\n    const chartMessages = buildChartMessages(snapshot, { forceClear: true });\n    outputs[0] = chartMessages.length ? chartMessages : [{ ui_control: { clear: true } }];\n    storeExportSnapshot(snapshot);\n    if (snapshot.labels.length) {\n        node.status({ fill: 'blue', shape: 'dot', text: `Готово к экспорту (${snapshot.labels.length})` });\n    } else {\n        node.status({ fill: 'yellow', shape: 'ring', text: 'Нет данных для экспорта' });\n    }\n    outputs[4] = {\n        action: 'flushResume',\n        topic: 'flushResume',\n        reason: 'cycleComplete',\n        ts: Date.now()\n    };\n    resetBuffer(buffer);\n}\n\nif (command === 'exportTrend') {\n    const ready = flow.get(EXPORT_READY_KEY);\n    const snapshot = getExportSnapshot();\n    if (ready && snapshot.labels.length) {\n        outputs[5] = {\n            topic: 'trendExport',\n            payload: snapshot,\n            ts: Date.now()\n        };\n        clearExportSnapshot();\n        node.status({ fill: 'green', shape: 'dot', text: `Экспортировано ${snapshot.labels.length}` });\n    } else {\n        node.status({ fill: 'yellow', shape: 'ring', text: 'Нет данных для экспорта' });\n    }\n}\n\nflow.set('trendBuffer', buffer);\nreturn outputs;\n",
        "outputs": 6,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 3050,
        "y": 380,
        "wires": [
            [
                "84d43b86639dc6f7"
            ],
            [
                "84d43b86639dc6f7"
            ],
            [
                "51b86f331d9e6007",
                "1da848c11508168c",
                "34254ea2950ef3fe"
            ],
            [
                "7afa9d48b0d9bec5"
            ],
            [
                "94a3f935717c9136"
            ],
            [
                "f91d90fd9a9b7b5c"
            ]
        ]
    }
]