# Анализ процесса измерений в контроллере итерации

## Версия: 131120251003

## 1. ТЕКУЩИЙ ПРОЦЕСС ИЗМЕРЕНИЙ

### 1.1. Инициализация измерений

**Триггер измерения:**
- Измерение запускается в функции `finishStep()` контроллера итерации
- Условие: `reason === 'completed'` (шаг завершён) И `pause >= 2` (пауза >= 2 мс)
- Если условие выполнено, создаётся сообщение с `reason: 'pauseMeasure'` и `measureDelay: halfPause` (половина паузы)

**Код в функции `finishStep()`:**
```javascript
if (reason === 'completed') {
    if (pause >= 2) {
        const halfPause = Math.max(1, Math.round(pause / 2));
        const measurementPayload = {
            payload: Number.isFinite(Number(state.value)) ? Number(state.value) : 0,
            iterationValue: Number.isFinite(Number(state.value)) ? Number(state.value) : 0,
            step: state.currentStep,
            reason: 'pauseMeasure',
            pause,
            measureDelay: halfPause,
            measureStep: state.currentStep,
            measure: true,
            ts: Date.now()
        };
        node.send([measurementPayload, null]);
    } else {
        applyZeroMeasurement(state.currentStep);
    }
}
```

### 1.2. Подготовка измерения

**Узел "Подготовка измерения AI" (id: b774050913c54c0a):**
- Проверяет флаг `msg.measure === true` или `msg.reason === 'pauseMeasure'`
- Извлекает задержку из `msg.measureDelay` или `msg.delay`
- Устанавливает `msg.delay` для узла delay
- Передаёт `msg.measureStep` (номер шага)

**Узел delay (id: b5a9d617eff46007):**
- Выполняет задержку `msg.delay` миллисекунд
- Использует динамическую задержку (`pauseType: "delayv"`)

### 1.3. Запрос измерения

**Узел "Сигнал измерения (6717)" (id: dded6f388ac2d1f6):**
- Устанавливает глобальную переменную `ITER_AI_MEASURE_STEP` = номер шага
- Устанавливает `msg.measure = true`
- Передаёт сообщение в узел `get-ai-value` (ADAM-6717)

**Узел "6717" (get-ai-value, id: 355b76c865a98d3c):**
- Читает все 8 каналов ADAM-6717
- Каждый канал отправляется в отдельный выход (8 выходов)

### 1.4. Обработка результатов измерения

**Узлы "Канал 1-8" (change nodes):**
- Каждый канал получает свой номер (1-8)
- Устанавливает `msg.aiChannel` = номер канала

**Узел "Обновление AI каналов" (id: 12d970b20f132d03) - КЛЮЧЕВОЙ УЗЕЛ:**

**Логика обработки:**
1. Извлекает номер канала из `msg.aiChannel`
2. Сохраняет текущее значение в `ITER_AI_CH{N}_CURRENT`
3. Проверяет, является ли это измерением:
   - `msg.measure === true` ИЛИ
   - `globalMeasureStep > 0` И `measureStepRaw === globalMeasureStep`
4. Использует `context.measurementState` для накопления значений всех 8 каналов
5. Когда получены все 8 каналов (`Object.keys(measurementState.values).length >= 8`):
   - Сохраняет результаты в `ITER_AI_CH{N}_RESULT` для каждого канала
   - Добавляет запись в `flow.aiMeasurementLog`
   - Устанавливает `flow.aiLastResultStep` = номер шага
   - Сохраняет результаты в глобальные переменные `ITER_AI_STEP{N}_CH{M}` для всех шагов
   - Сбрасывает `ITER_AI_MEASURE_STEP` = 0
   - Отправляет сообщение `trendMsg` с `topic: 'aiSample'` для графика

**Важные переменные:**
- `ITER_AI_CH{N}_CURRENT` - текущее значение канала (обновляется постоянно)
- `ITER_AI_CH{N}_RESULT` - результат измерения канала (обновляется только при завершении измерения всех 8 каналов)
- `ITER_AI_STEP{N}_CH{M}` - результат шага N, канал M (сохраняется при завершении измерения)
- `ITER_AI_MEASURE_STEP` - номер шага, для которого выполняется измерение (сбрасывается в 0 после завершения)
- `flow.aiLastResultStep` - последний шаг, для которого получены результаты

### 1.5. Получение измеренного значения после изменения результата итерации

**Текущий механизм:**
1. При изменении `ITERATION_VALUE` (каждый тик итерации) контроллер отправляет сообщение с `reason: 'tick'`
2. Это сообщение НЕ связано напрямую с измерением
3. Измерение происходит только при завершении шага (`reason: 'completed'`) с паузой >= 2 мс
4. Результаты измерения сохраняются в `ITER_AI_CH{N}_RESULT` и `ITER_AI_STEP{N}_CH{M}`

**Проблема:**
- Измерение происходит только в середине паузы после завершения шага
- Нет механизма получения измеренного значения сразу после изменения `ITERATION_VALUE`
- Если нужно получить измерение при каждом изменении итерации, текущая логика не поддерживает это

## 2. ВЫЯВЛЕННЫЕ ПРОБЛЕМЫ И ОГРАНИЧЕНИЯ

### 2.1. Временная привязка измерений
- Измерение происходит только в середине паузы после завершения шага
- Нет измерения во время выполнения шага (между тиками)
- Нет измерения при каждом изменении `ITERATION_VALUE`

### 2.2. Синхронизация измерений с итерацией
- Измерение запускается с задержкой `halfPause` после завершения шага
- К моменту измерения `ITERATION_VALUE` уже установлено в конечное значение шага
- Нет гарантии, что измерение соответствует конкретному значению `ITERATION_VALUE`

### 2.3. Обработка результатов
- Результаты сохраняются только после получения всех 8 каналов
- Если один из каналов не получен, результаты не сохраняются
- Нет механизма обработки частичных результатов

### 2.4. Получение результатов
- Результаты доступны через глобальные переменные `ITER_AI_CH{N}_RESULT`
- Результаты по шагам доступны через `ITER_AI_STEP{N}_CH{M}`
- Нет прямого механизма получения результата для конкретного значения `ITERATION_VALUE`

## 3. ПЛАН ДЕЙСТВИЙ ДЛЯ УЛУЧШЕНИЯ

### 3.1. Добавить измерение при каждом изменении ITERATION_VALUE

**Задача:** Получать измерение сразу после каждого изменения `ITERATION_VALUE`

**Решение:**
1. В функции `scheduleNextTick()` контроллера, после установки нового значения:
   - Добавить отправку сообщения с запросом измерения
   - Указать текущее значение `ITERATION_VALUE` и номер шага
   - Добавить небольшую задержку для стабилизации (опционально)

2. Модифицировать узел "Подготовка измерения AI":
   - Поддержать измерение с `reason: 'tick'` (не только `pauseMeasure`)
   - Добавить параметр задержки стабилизации

3. Обновить узел "Обновление AI каналов":
   - Сохранять `ITERATION_VALUE` вместе с результатами измерения
   - Добавить в `aiMeasurementLog` поле `iterationValue`

### 3.2. Улучшить синхронизацию измерений с итерацией

**Задача:** Гарантировать, что измерение соответствует конкретному значению `ITERATION_VALUE`

**Решение:**
1. В сообщении измерения всегда передавать:
   - `iterationValue` - текущее значение итерации
   - `iterationStep` - текущий номер шага
   - `measureStep` - номер шага для измерения

2. При сохранении результатов в `ITER_AI_STEP{N}_CH{M}`:
   - Сохранять также `ITER_AI_STEP{N}_VALUE` - значение итерации на момент измерения

3. Добавить функцию получения результата по значению итерации:
   - Поиск ближайшего измерения для заданного `ITERATION_VALUE`
   - Возврат результатов всех каналов для этого значения

### 3.3. Добавить механизм получения результата после изменения итерации

**Задача:** Предоставить простой способ получить измеренное значение после любого изменения `ITERATION_VALUE`

**Решение:**
1. Добавить глобальную переменную `ITER_AI_LAST_MEASUREMENT`:
   - Структура: `{ iterationValue, step, values: [ch1, ch2, ..., ch8], ts }`
   - Обновляется при каждом завершении измерения

2. Добавить функцию-утилиту для получения результата:
   ```javascript
   function getMeasurementForValue(iterationValue) {
       const log = flow.get('aiMeasurementLog') || [];
       // Поиск ближайшего измерения для заданного значения
       // ...
   }
   ```

3. Добавить узел для запроса результата:
   - Вход: `iterationValue` или `step`
   - Выход: результаты измерения для этого значения/шага

### 3.4. Улучшить обработку частичных результатов

**Задача:** Обрабатывать случаи, когда не все каналы получены

**Решение:**
1. Добавить таймаут для измерения:
   - Если в течение заданного времени не получены все 8 каналов, использовать частичные результаты
   - Сохранять только полученные каналы

2. Добавить флаг завершённости измерения:
   - `ITER_AI_MEASUREMENT_COMPLETE` - все каналы получены
   - `ITER_AI_MEASUREMENT_PARTIAL` - получены не все каналы

### 3.5. Добавить визуализацию связи измерений с итерацией

**Задача:** Показать на графике, когда происходили измерения

**Решение:**
1. На графике итерации добавить маркеры измерений:
   - Вертикальные линии в моменты измерений
   - Подписи с номером шага и значением итерации

2. Добавить таблицу измерений:
   - Колонки: Время, Шаг, ITERATION_VALUE, Каналы 1-8
   - Сортировка по времени или значению итерации

## 4. ПРИОРИТЕТЫ РЕАЛИЗАЦИИ

### Высокий приоритет:
1. ✅ Добавить измерение при каждом изменении ITERATION_VALUE (3.1)
2. ✅ Улучшить синхронизацию измерений с итерацией (3.2)
3. ✅ Добавить механизм получения результата после изменения итерации (3.3)

### Средний приоритет:
4. Улучшить обработку частичных результатов (3.4)
5. Добавить визуализацию связи измерений с итерацией (3.5)

### Низкий приоритет:
6. Оптимизация производительности при частых измерениях
7. Добавление статистики измерений

## 5. ТЕХНИЧЕСКИЕ ДЕТАЛИ РЕАЛИЗАЦИИ

### 5.1. Изменения в контроллере итерации

**Функция `scheduleNextTick()`:**
- После `setValue(nextValue)` добавить:
  ```javascript
  if (state.control === 1) {
      const measurementMsg = {
          payload: nextValue,
          iterationValue: nextValue,
          step: state.currentStep,
          reason: 'tick',
          measure: true,
          measureStep: state.currentStep,
          measureDelay: 10, // Задержка стабилизации (мс)
          ts: Date.now()
      };
      node.send([null, null, null, null, null, measurementMsg]);
  }
  ```

### 5.2. Изменения в узле "Подготовка измерения AI"

- Поддержать `reason: 'tick'`:
  ```javascript
  const isMeasurement = msg.measure === true || 
                        msg.reason === 'pauseMeasure' || 
                        msg.reason === 'tick';
  ```

### 5.3. Изменения в узле "Обновление AI каналов"

- Сохранять `iterationValue` в `measurementState`:
  ```javascript
  if (isMeasurement && Number.isFinite(measureStepRaw) && measureStepRaw > 0) {
      if (measurementState.step !== measureStepRaw) {
          measurementState = { 
              step: measureStepRaw, 
              values: {},
              iterationValue: msg.iterationValue || 0
          };
      }
      // ...
  }
  ```

- При завершении измерения сохранять `iterationValue`:
  ```javascript
  const entry = {
      ts: Date.now(),
      step: safeStep,
      iterationValue: measurementState.iterationValue || 0,
      values: vector.slice(0, 8).map(...),
      source
  };
  ```

- Обновлять глобальную переменную `ITER_AI_LAST_MEASUREMENT`:
  ```javascript
  global.set('ITER_AI_LAST_MEASUREMENT', JSON.stringify({
      iterationValue: entry.iterationValue,
      step: entry.step,
      values: entry.values,
      ts: entry.ts
  }));
  ```

## 6. ВОПРОСЫ ДЛЯ УТОЧНЕНИЯ

1. **Частота измерений:**
   - Нужно ли измерение при каждом тике итерации (каждое изменение ITERATION_VALUE)?
   - Или достаточно измерения только при завершении шага?

2. **Задержка стабилизации:**
   - Какая задержка нужна между изменением ITERATION_VALUE и измерением?
   - Зависит ли задержка от скорости шага?

3. **Обработка частичных результатов:**
   - Что делать, если не все 8 каналов получены?
   - Использовать частичные результаты или повторять измерение?

4. **Хранение истории:**
   - Сколько измерений хранить в `aiMeasurementLog`?
   - Нужна ли очистка старых измерений?

5. **Производительность:**
   - Не повлияет ли частое измерение на производительность системы?
   - Нужна ли оптимизация для снижения нагрузки?

---

**Дата анализа:** 2025-11-13
**Версия кода:** 131120251003
