# Анализ процесса измерений в контроллере итерации

## Версия: 131120251003

## КРАТКОЕ РЕЗЮМЕ

**Важное открытие:** В системе есть два разных процесса:

1. **Настоящее измерение (запрос к ADAM-6717):**
   - Происходит только в середине паузы после завершения шага (если пауза >= 2 мс)
   - Это реальный запрос к модулю для чтения всех 8 каналов
   - Обновляет `ITER_AI_CH{N}_CURRENT` и `ITER_AI_CH{N}_RESULT`

2. **Чтение текущих значений (при каждом тике):**
   - Происходит при каждом изменении `ITERATION_VALUE` (каждый тик)
   - Читает значения из `ITER_AI_CH{N}_CURRENT` (не запрашивает у ADAM-6717)
   - Эти данные формируют экспортируемый файл с колонками `ai_elapsed_ms;iteration_value;ai_ch1;...`
   - **Проблема:** Между настоящими измерениями значения каналов не меняются (показывают последнее измеренное значение)

**Вывод:** Данные в экспорте формируются при каждом тике, но это не новые измерения - это чтение последних известных значений. Для получения реальных измерений при каждом изменении итерации нужно добавить запрос к ADAM-6717 при каждом тике.

## 1. ТЕКУЩИЙ ПРОЦЕСС ИЗМЕРЕНИЙ

### 1.1. Два типа "измерений"

**ВАЖНО:** В системе есть два разных процесса, которые можно назвать "измерениями":

#### A. Запрос к ADAM-6717 (настоящее измерение)
**Триггер измерения:**
- Измерение запускается в функции `finishStep()` контроллера итерации
- Условие: `reason === 'completed'` (шаг завершён) И `pause >= 2` (пауза >= 2 мс)
- Если условие выполнено, создаётся сообщение с `reason: 'pauseMeasure'` и `measureDelay: halfPause` (половина паузы)
- Это **настоящий запрос** к модулю ADAM-6717 для чтения всех 8 каналов

#### B. Чтение текущих значений (при каждом тике)
**Триггер чтения:**
- При каждом тике итерации (`reason: 'tick'`) функция `broadcast()` в контроллере итерации читает текущие значения из глобальных переменных `ITER_AI_CH{N}_CURRENT`
- Эти значения **не запрашиваются** у ADAM-6717, а просто читаются из памяти
- Данные отправляются в буфер тренда ADAM-6717 для отображения на графике и экспорта
- **Именно эти данные** формируют экспортируемый файл с колонками `ai_elapsed_ms;iteration_value;ai_ch1;ai_ch2;...`

**Код в функции `finishStep()`:**
```javascript
if (reason === 'completed') {
    if (pause >= 2) {
        const halfPause = Math.max(1, Math.round(pause / 2));
        const measurementPayload = {
            payload: Number.isFinite(Number(state.value)) ? Number(state.value) : 0,
            iterationValue: Number.isFinite(Number(state.value)) ? Number(state.value) : 0,
            step: state.currentStep,
            reason: 'pauseMeasure',
            pause,
            measureDelay: halfPause,
            measureStep: state.currentStep,
            measure: true,
            ts: Date.now()
        };
        node.send([measurementPayload, null]);
    } else {
        applyZeroMeasurement(state.currentStep);
    }
}
```

### 1.2. Процесс A: Запрос к ADAM-6717 (настоящее измерение)

#### Подготовка измерения

**Узел "Подготовка измерения AI" (id: b774050913c54c0a):**
- Проверяет флаг `msg.measure === true` или `msg.reason === 'pauseMeasure'`
- Извлекает задержку из `msg.measureDelay` или `msg.delay`
- Устанавливает `msg.delay` для узла delay
- Передаёт `msg.measureStep` (номер шага)

**Узел delay (id: b5a9d617eff46007):**
- Выполняет задержку `msg.delay` миллисекунд
- Использует динамическую задержку (`pauseType: "delayv"`)

#### Запрос измерения

**Узел "Сигнал измерения (6717)" (id: dded6f388ac2d1f6):**
- Устанавливает глобальную переменную `ITER_AI_MEASURE_STEP` = номер шага
- Устанавливает `msg.measure = true`
- Передаёт сообщение в узел `get-ai-value` (ADAM-6717)

**Узел "6717" (get-ai-value, id: 355b76c865a98d3c):**
- Читает все 8 каналов ADAM-6717
- Каждый канал отправляется в отдельный выход (8 выходов)

#### Обработка результатов измерения

**Узлы "Канал 1-8" (change nodes):**
- Каждый канал получает свой номер (1-8)
- Устанавливает `msg.aiChannel` = номер канала

**Узел "Обновление AI каналов" (id: 12d970b20f132d03) - КЛЮЧЕВОЙ УЗЕЛ:**

**Логика обработки:**
1. Извлекает номер канала из `msg.aiChannel`
2. Сохраняет текущее значение в `ITER_AI_CH{N}_CURRENT`
3. Проверяет, является ли это измерением:
   - `msg.measure === true` ИЛИ
   - `globalMeasureStep > 0` И `measureStepRaw === globalMeasureStep`
4. Использует `context.measurementState` для накопления значений всех 8 каналов
5. Когда получены все 8 каналов (`Object.keys(measurementState.values).length >= 8`):
   - Сохраняет результаты в `ITER_AI_CH{N}_RESULT` для каждого канала
   - Добавляет запись в `flow.aiMeasurementLog`
   - Устанавливает `flow.aiLastResultStep` = номер шага
   - Сохраняет результаты в глобальные переменные `ITER_AI_STEP{N}_CH{M}` для всех шагов
   - Сбрасывает `ITER_AI_MEASURE_STEP` = 0
   - Отправляет сообщение `trendMsg` с `topic: 'aiSample'` для графика

**Важные переменные:**
- `ITER_AI_CH{N}_CURRENT` - текущее значение канала (обновляется постоянно)
- `ITER_AI_CH{N}_RESULT` - результат измерения канала (обновляется только при завершении измерения всех 8 каналов)
- `ITER_AI_STEP{N}_CH{M}` - результат шага N, канал M (сохраняется при завершении измерения)
- `ITER_AI_MEASURE_STEP` - номер шага, для которого выполняется измерение (сбрасывается в 0 после завершения)
- `flow.aiLastResultStep` - последний шаг, для которого получены результаты

### 1.3. Процесс B: Чтение текущих значений при каждом тике

**Как это работает:**

1. **При каждом тике итерации** (`reason: 'tick'`):
   - Функция `broadcast()` в контроллере итерации вызывается с `includeValue = true`
   - Она читает текущие значения из глобальных переменных `ITER_AI_CH{N}_CURRENT`:
     ```javascript
     const channels = [];
     for (let ch = 1; ch <= 8; ch += 1) {
         const current = Number(global.get(`ITER_AI_CH${ch}_CURRENT`));
         channels.push(Number.isFinite(current) ? current : 0);
     }
     ```
   - Создаётся сообщение с полем `aiTrend`, содержащим эти значения
   - Сообщение отправляется в узел "Буфер тренда ADAM-6717"

2. **Узел "Буфер тренда ADAM-6717"** (id: e4d2c1b0a9f8e7d6):
   - Функция `buildSampleFromMessage()` извлекает данные из `msg.aiTrend`
   - Данные добавляются в буфер `aiTrendBuffer` с относительным временем
   - Эти данные используются для:
     - Отображения на графике ADAM-6717
     - Экспорта в файл (колонки `ai_elapsed_ms;iteration_value;ai_ch1;ai_ch2;...`)

3. **Откуда берутся значения `ITER_AI_CH{N}_CURRENT`:**
   - Эти переменные обновляются узлом "Обновление AI каналов" при получении данных от ADAM-6717
   - Но обновление происходит **только при настоящем измерении** (процесс A)
   - Между измерениями значения остаются **неизменными** (последние полученные значения)

### 1.4. Получение измеренного значения после изменения результата итерации

**Текущий механизм:**
1. При изменении `ITERATION_VALUE` (каждый тик) контроллер отправляет сообщение с `reason: 'tick'`
2. Это сообщение содержит **текущие значения** из `ITER_AI_CH{N}_CURRENT` (не новые измерения)
3. Настоящее измерение (запрос к ADAM-6717) происходит только при завершении шага (`reason: 'completed'`) с паузой >= 2 мс
4. Результаты настоящего измерения сохраняются в `ITER_AI_CH{N}_RESULT` и `ITER_AI_STEP{N}_CH{M}`

**Важное понимание:**
- Данные в экспортируемом файле (`ai_elapsed_ms;iteration_value;ai_ch1;...`) формируются при каждом тике
- Но это **не новые измерения** - это чтение последних известных значений из `ITER_AI_CH{N}_CURRENT`
- Новые измерения (запрос к ADAM-6717) происходят только в середине паузы после завершения шага
- Между измерениями значения каналов в экспорте **не меняются** (показывают последнее измеренное значение)

## 2. ВЫЯВЛЕННЫЕ ПРОБЛЕМЫ И ОГРАНИЧЕНИЯ

### 2.1. Различие между чтением и измерением
- **Проблема:** Данные в экспорте формируются при каждом тике, но это не новые измерения
- **Детали:** 
  - При каждом тике читаются значения из `ITER_AI_CH{N}_CURRENT`
  - Эти значения обновляются только при настоящем измерении (в середине паузы)
  - Между измерениями значения каналов в экспорте **не меняются** (показывают последнее измеренное значение)
- **Следствие:** В экспортируемом файле много строк с одинаковыми значениями каналов, но разными `iteration_value`

### 2.2. Временная привязка настоящих измерений
- Настоящее измерение (запрос к ADAM-6717) происходит только в середине паузы после завершения шага
- Нет измерения во время выполнения шага (между тиками)
- Нет измерения при каждом изменении `ITERATION_VALUE`
- Если пауза < 2 мс, измерение вообще не выполняется

### 2.3. Синхронизация измерений с итерацией
- Измерение запускается с задержкой `halfPause` после завершения шага
- К моменту измерения `ITERATION_VALUE` уже установлено в конечное значение шага
- Нет гарантии, что измерение соответствует конкретному значению `ITERATION_VALUE` во время выполнения шага
- Измерение происходит **после** завершения шага, а не во время его выполнения

### 2.4. Обработка результатов
- Результаты сохраняются только после получения всех 8 каналов
- Если один из каналов не получен, результаты не сохраняются
- Нет механизма обработки частичных результатов

### 2.5. Получение результатов
- Результаты доступны через глобальные переменные `ITER_AI_CH{N}_RESULT`
- Результаты по шагам доступны через `ITER_AI_STEP{N}_CH{M}`
- Нет прямого механизма получения результата для конкретного значения `ITERATION_VALUE`
- В экспорте показываются последние известные значения, а не значения, измеренные для конкретного `iteration_value`

## 3. ПЛАН ДЕЙСТВИЙ ДЛЯ УЛУЧШЕНИЯ

### 3.1. Добавить настоящее измерение при каждом изменении ITERATION_VALUE

**Задача:** Выполнять настоящий запрос к ADAM-6717 при каждом изменении `ITERATION_VALUE` (каждый тик)

**Текущая ситуация:**
- При каждом тике читаются значения из `ITER_AI_CH{N}_CURRENT` (последние известные)
- Настоящее измерение происходит только в середине паузы после завершения шага
- В экспорте много строк с одинаковыми значениями каналов

**Решение:**
1. В функции `scheduleNextTick()` контроллера, после установки нового значения (`setValue(nextValue)`):
   - Добавить отправку сообщения с запросом настоящего измерения
   - Указать текущее значение `ITERATION_VALUE` и номер шага
   - Добавить небольшую задержку для стабилизации (опционально, например 10-50 мс)

2. Модифицировать узел "Подготовка измерения AI":
   - Поддержать измерение с `reason: 'tick'` (не только `pauseMeasure`)
   - Добавить параметр задержки стабилизации (можно использовать `msg.measureDelay`)

3. Обновить узел "Обновление AI каналов":
   - Сохранять `ITERATION_VALUE` вместе с результатами измерения
   - Добавить в `aiMeasurementLog` поле `iterationValue`
   - Обновлять `ITER_AI_CH{N}_CURRENT` при каждом измерении (уже делается)

### 3.2. Улучшить синхронизацию измерений с итерацией

**Задача:** Гарантировать, что измерение соответствует конкретному значению `ITERATION_VALUE`

**Решение:**
1. В сообщении измерения всегда передавать:
   - `iterationValue` - текущее значение итерации
   - `iterationStep` - текущий номер шага
   - `measureStep` - номер шага для измерения

2. При сохранении результатов в `ITER_AI_STEP{N}_CH{M}`:
   - Сохранять также `ITER_AI_STEP{N}_VALUE` - значение итерации на момент измерения

3. Добавить функцию получения результата по значению итерации:
   - Поиск ближайшего измерения для заданного `ITERATION_VALUE`
   - Возврат результатов всех каналов для этого значения

### 3.3. Добавить механизм получения результата после изменения итерации

**Задача:** Предоставить простой способ получить измеренное значение после любого изменения `ITERATION_VALUE`

**Решение:**
1. Добавить глобальную переменную `ITER_AI_LAST_MEASUREMENT`:
   - Структура: `{ iterationValue, step, values: [ch1, ch2, ..., ch8], ts }`
   - Обновляется при каждом завершении измерения

2. Добавить функцию-утилиту для получения результата:
   ```javascript
   function getMeasurementForValue(iterationValue) {
       const log = flow.get('aiMeasurementLog') || [];
       // Поиск ближайшего измерения для заданного значения
       // ...
   }
   ```

3. Добавить узел для запроса результата:
   - Вход: `iterationValue` или `step`
   - Выход: результаты измерения для этого значения/шага

### 3.4. Улучшить обработку частичных результатов

**Задача:** Обрабатывать случаи, когда не все каналы получены

**Решение:**
1. Добавить таймаут для измерения:
   - Если в течение заданного времени не получены все 8 каналов, использовать частичные результаты
   - Сохранять только полученные каналы

2. Добавить флаг завершённости измерения:
   - `ITER_AI_MEASUREMENT_COMPLETE` - все каналы получены
   - `ITER_AI_MEASUREMENT_PARTIAL` - получены не все каналы

### 3.5. Добавить визуализацию связи измерений с итерацией

**Задача:** Показать на графике, когда происходили измерения

**Решение:**
1. На графике итерации добавить маркеры измерений:
   - Вертикальные линии в моменты измерений
   - Подписи с номером шага и значением итерации

2. Добавить таблицу измерений:
   - Колонки: Время, Шаг, ITERATION_VALUE, Каналы 1-8
   - Сортировка по времени или значению итерации

## 4. ПРИОРИТЕТЫ РЕАЛИЗАЦИИ

### Высокий приоритет:
1. ✅ Добавить измерение при каждом изменении ITERATION_VALUE (3.1)
2. ✅ Улучшить синхронизацию измерений с итерацией (3.2)
3. ✅ Добавить механизм получения результата после изменения итерации (3.3)

### Средний приоритет:
4. Улучшить обработку частичных результатов (3.4)
5. Добавить визуализацию связи измерений с итерацией (3.5)

### Низкий приоритет:
6. Оптимизация производительности при частых измерениях
7. Добавление статистики измерений

## 5. ТЕХНИЧЕСКИЕ ДЕТАЛИ РЕАЛИЗАЦИИ

### 5.1. Изменения в контроллере итерации

**Функция `scheduleNextTick()`:**
- После `setValue(nextValue)` добавить:
  ```javascript
  if (state.control === 1) {
      const measurementMsg = {
          payload: nextValue,
          iterationValue: nextValue,
          step: state.currentStep,
          reason: 'tick',
          measure: true,
          measureStep: state.currentStep,
          measureDelay: 10, // Задержка стабилизации (мс)
          ts: Date.now()
      };
      node.send([null, null, null, null, null, measurementMsg]);
  }
  ```

### 5.2. Изменения в узле "Подготовка измерения AI"

- Поддержать `reason: 'tick'`:
  ```javascript
  const isMeasurement = msg.measure === true || 
                        msg.reason === 'pauseMeasure' || 
                        msg.reason === 'tick';
  ```

### 5.3. Изменения в узле "Обновление AI каналов"

- Сохранять `iterationValue` в `measurementState`:
  ```javascript
  if (isMeasurement && Number.isFinite(measureStepRaw) && measureStepRaw > 0) {
      if (measurementState.step !== measureStepRaw) {
          measurementState = { 
              step: measureStepRaw, 
              values: {},
              iterationValue: msg.iterationValue || 0
          };
      }
      // ...
  }
  ```

- При завершении измерения сохранять `iterationValue`:
  ```javascript
  const entry = {
      ts: Date.now(),
      step: safeStep,
      iterationValue: measurementState.iterationValue || 0,
      values: vector.slice(0, 8).map(...),
      source
  };
  ```

- Обновлять глобальную переменную `ITER_AI_LAST_MEASUREMENT`:
  ```javascript
  global.set('ITER_AI_LAST_MEASUREMENT', JSON.stringify({
      iterationValue: entry.iterationValue,
      step: entry.step,
      values: entry.values,
      ts: entry.ts
  }));
  ```

## 6. ВОПРОСЫ ДЛЯ УТОЧНЕНИЯ

1. **Частота измерений:**
   - Нужно ли измерение при каждом тике итерации (каждое изменение ITERATION_VALUE)?
   - Или достаточно измерения только при завершении шага?

2. **Задержка стабилизации:**
   - Какая задержка нужна между изменением ITERATION_VALUE и измерением?
   - Зависит ли задержка от скорости шага?

3. **Обработка частичных результатов:**
   - Что делать, если не все 8 каналов получены?
   - Использовать частичные результаты или повторять измерение?

4. **Хранение истории:**
   - Сколько измерений хранить в `aiMeasurementLog`?
   - Нужна ли очистка старых измерений?

5. **Производительность:**
   - Не повлияет ли частое измерение на производительность системы?
   - Нужна ли оптимизация для снижения нагрузки?

---

**Дата анализа:** 2025-11-13
**Версия кода:** 131120251003
